using CodeOptimizer.Models;
using System.Text.RegularExpressions;

namespace CodeOptimizer.Services
{
    public class ProjectSolutionScanner
    {
        private readonly string[] _csharpExtensions = { ".cs" };
        private readonly string[] _excludePatterns = { "bin", "obj", "packages", ".git", ".vs", "Debug", "Release" };
        
        public async Task<List<CodeFile>> ScanSolutionAsync(string solutionPath)
        {
            var codeFiles = new List<CodeFile>();
            var rootDirectory = Path.GetDirectoryName(solutionPath) ?? solutionPath;
            
            Console.WriteLine($"Scanning solution at: {rootDirectory}");
            
            // Find all C# files in the solution
            var csFiles = Directory.GetFiles(rootDirectory, "*.cs", SearchOption.AllDirectories)
                .Where(file => !IsExcluded(file))
                .ToList();
            
            Console.WriteLine($"Found {csFiles.Count} C# files to analyze.");
            
            foreach (var filePath in csFiles)
            {
                try
                {
                    var content = await File.ReadAllTextAsync(filePath);
                    
                    // Skip empty files or files with only whitespace
                    if (string.IsNullOrWhiteSpace(content))
                        continue;
                    
                    // Skip auto-generated files
                    if (IsAutoGeneratedFile(content))
                        continue;
                    
                    codeFiles.Add(new CodeFile
                    {
                        FilePath = filePath,
                        Content = content,
                        Language = "csharp"
                    });
                    
                    Console.WriteLine($"Added file: {Path.GetFileName(filePath)}");
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error reading file {filePath}: {ex.Message}");
                }
            }
            
            return codeFiles;
        }
        
        private bool IsExcluded(string filePath)
        {
            return _excludePatterns.Any(pattern => 
                filePath.Contains(pattern, StringComparison.OrdinalIgnoreCase));
        }
        
        private bool IsAutoGeneratedFile(string content)
        {
            var autoGeneratedIndicators = new[]
            {
                "<auto-generated",
                "This code was generated",
                "// <auto-generated>",
                "Designer.cs",
                ".Designer.cs",
                "AssemblyInfo.cs",
                "GlobalAssemblyInfo.cs",
                "TemporaryGeneratedFile"
            };
            
            return autoGeneratedIndicators.Any(indicator => 
                content.Contains(indicator, StringComparison.OrdinalIgnoreCase));
        }
        
        public List<CodeFile> PrioritizeFiles(List<CodeFile> codeFiles)
        {
            // Prioritize files based on potential optimization impact
            return codeFiles.OrderByDescending(file => CalculateOptimizationPriority(file)).ToList();
        }
        
        private int CalculateOptimizationPriority(CodeFile file)
        {
            int priority = 0;
            var content = file.Content;
            
            // Higher priority for files with known optimization opportunities
            if (content.Contains("string +") || content.Contains("+ string")) priority += 10;
            if (content.Contains("new List<") && !content.Contains("Capacity")) priority += 8;
            if (content.Contains("foreach") && content.Contains("+=")) priority += 7;
            if (content.Contains("ToList()") && content.Contains("ToArray()")) priority += 6;
            if (content.Contains("boxing") || Regex.IsMatch(content, @"object\s*\[\s*\]")) priority += 5;
            if (content.Contains("async") && content.Contains("Task.Run")) priority += 4;
            if (content.Contains("IDisposable") && !content.Contains("using")) priority += 9;
            if (content.Contains("StringBuilder") == false && content.Contains("string result")) priority += 6;
            
            // Consider file size (larger files might have more opportunities)
            priority += Math.Min(content.Length / 1000, 10);
            
            return priority;
        }
    }
}
