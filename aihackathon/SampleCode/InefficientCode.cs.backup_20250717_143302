// Sample code with memory optimization opportunities
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;

namespace SampleCode
{
    // This class contains inefficient code that demonstrates various memory optimization opportunities
    public class InefficientDataProcessor
    {
        // INEFFICIENT: String concatenation in loop causes multiple string allocations
        public string ProcessData(List<string> data)
        {
            // Memory inefficient: String concatenation in loop
            string result = "";
            foreach (var item in data)
            {
                result += item + ", ";
            }
            
            // Memory inefficient: Boxing in LINQ with object collection
            var numbers = new List<object>();
            for (int i = 0; i < 1000; i++)
            {
                numbers.Add(i); // Boxing int to object
            }
            
            // Memory inefficient: Multiple enumerations and unnecessary intermediate collections
            var filteredNumbers = numbers.Where(x => (int)x > 500).ToList();
            var processedNumbers = filteredNumbers.Select(x => x.ToString()).ToList();
            
            // Memory inefficient: Not using 'using' statements for proper disposal
            var fileStream = new FileStream("temp.txt", FileMode.Create);
            var writer = new StreamWriter(fileStream);
            writer.Write(result);
            writer.Close();
            fileStream.Close();
            
            return result;
        }

        // INEFFICIENT: Loading large amounts of data at once without capacity specification
        public List<Customer> GetCustomers()
        {
            // Memory inefficient: No capacity specified, causes multiple array resizes
            var customers = new List<Customer>();
            for (int i = 0; i < 10000; i++)
            {
                customers.Add(new Customer 
                { 
                    Id = i, 
                    Name = "Customer " + i.ToString(), // String concatenation instead of interpolation
                    Email = "customer" + i.ToString() + "@example.com",
                    Orders = new List<Order>()
                });
            }
            return customers;
        }

        // INEFFICIENT: Multiple enumerations of the same collection
        public void ProcessLargeDataSet(List<int> data)
        {
            // Each of these operations enumerates the entire collection separately
            var count = data.Count();
            var sum = data.Sum();
            var average = data.Average();
            var max = data.Max();
            var min = data.Min();
            
            // Creating unnecessary intermediate collections
            var evenNumbers = data.Where(x => x % 2 == 0).ToList();
            var oddNumbers = data.Where(x => x % 2 != 0).ToList();
            
            // String concatenation in loop
            string report = "";
            for (int i = 0; i < data.Count; i++)
            {
                report += $"Item {i}: {data[i]}\n";
            }
            
            Console.WriteLine(report);
        }

        // INEFFICIENT: Multiple passes through data instead of single pass
        public List<string> FilterAndTransformData(List<string> input)
        {
            // First pass: filter
            var filtered = new List<string>();
            foreach (var item in input)
            {
                if (item.Length > 3)
                {
                    filtered.Add(item);
                }
            }
            
            // Second pass: transform to uppercase
            var transformed = new List<string>();
            foreach (var item in filtered)
            {
                transformed.Add(item.ToUpper());
            }
            
            // Third pass: add suffix
            var final = new List<string>();
            foreach (var item in transformed)
            {
                final.Add(item + "_PROCESSED");
            }
            
            return final;
        }

        // INEFFICIENT: Event handlers that can cause memory leaks
        public void SetupEventHandlers()
        {
            var publisher = new EventPublisher();
            var processor = new DataProcessor();
            
            // Potential memory leak: not unsubscribing from events
            publisher.DataReceived += processor.ProcessData;
            publisher.ErrorOccurred += processor.HandleError;
            
            // Publisher keeps references to processor, preventing garbage collection
            // Missing: Proper cleanup/unsubscription
        }

        // INEFFICIENT: Creating unnecessary temporary objects
        public double CalculateStatistics(List<double> values)
        {
            // Creates temporary lists instead of using single enumeration
            var sortedValues = values.OrderBy(x => x).ToList();
            var positiveValues = values.Where(x => x > 0).ToList();
            var negativeValues = values.Where(x => x < 0).ToList();
            
            // Multiple string concatenations
            string summary = "";
            summary += "Total: " + values.Count.ToString();
            summary += ", Positive: " + positiveValues.Count.ToString();
            summary += ", Negative: " + negativeValues.Count.ToString();
            
            Console.WriteLine(summary);
            
            return sortedValues.Average();
        }

        // INEFFICIENT: Loading data synchronously when async would be better
        public List<string> LoadDataFromFile(string filePath)
        {
            // Synchronous file reading - blocks thread
            var lines = new List<string>();
            using (var reader = new StreamReader(filePath))
            {
                string? line;
                while ((line = reader.ReadLine()) != null)
                {
                    lines.Add(line);
                }
            }
            
            // Processing each line separately instead of batch processing
            var processedLines = new List<string>();
            foreach (var line in lines)
            {
                processedLines.Add(line.Trim().ToUpper());
            }
            
            return processedLines;
        }
    }
    
    // Supporting classes for the inefficient code examples
    public class Customer
    {
        public int Id { get; set; }
        public string Name { get; set; } = "";
        public string Email { get; set; } = "";
        public List<Order> Orders { get; set; } = new List<Order>();
    }
    
    public class Order
    {
        public int Id { get; set; }
        public DateTime OrderDate { get; set; }
        public decimal Amount { get; set; }
        public string Description { get; set; } = "";
    }

    // Event handler classes for memory leak example
    public class EventPublisher
    {
        public event Action<string>? DataReceived;
        public event Action<Exception>? ErrorOccurred;
        
        public void PublishData(string data)
        {
            DataReceived?.Invoke(data);
        }
        
        public void PublishError(Exception error)
        {
            ErrorOccurred?.Invoke(error);
        }
    }
    
    public class DataProcessor
    {
        public void ProcessData(string data)
        {
            // Process the data
            Console.WriteLine($"Processing: {data}");
        }
        
        public void HandleError(Exception error)
        {
            // Handle the error
            Console.WriteLine($"Error: {error.Message}");
        }
    }
}
